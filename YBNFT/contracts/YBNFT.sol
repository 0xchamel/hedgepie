// SPDX-License-Identifier: None
pragma solidity ^0.8.0;

/// @dev OZ inheritance
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/// @dev OZ interfaces
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

/// @dev other architecture interfaces
import "./interfaces/IRNG.sol";

contract YBNFT is ERC721, Ownable{

    address public treasury;
    address public lottery;
    address public RNG;
    uint public a = 0;
    uint public b = 500;
    uint private nonce = 0;

    address[] private tokensHeld;
    mapping(uint => uint) public boosts;
    mapping(address => bool) public pending;

    constructor(address _treasury, address _lottery, address _rng) ERC721("RUBY Yeild Baring NFT", "YBNFT") Ownable(){
        treasury = _treasury;
        lottery = _lottery;
        RNG = _rng;
    }

    /// @dev setter for Treasury address
    function setTreasury(address _new) external onlyOwner{
        treasury = _new;
    }

    /// @dev setter for Lottery address
    function setLottery(address _new) external onlyOwner{
        lottery = _new;
    }

    /// @dev setter for RNG address
    function setRNG(address _new) external onlyOwner{
        RNG = _new;
    }

    /// @dev setter for A val
    function setA(uint _new) external onlyOwner{
        a = _new;
    }

    /// @dev setter for B val
    function setB(uint _new) external onlyOwner{
        b = _new;
    }

    /// @dev function to receive ether
    receive() external payable{}

    /**
    * @dev deposit function to receive ERC20s
    * @param _what is the token being received
    * @param _amount is the amount being received
     */
    function deposit(address _what, uint _amount) external{
        tokensHeld.push(_what);
        IERC20(_what).transferFrom(msg.sender, address(this), _amount);
    }

    /**
    * @dev function for the Lottery contract to call. Submits RNG for a winners NFT. Then can claim it after the RNG blocks pass
    * @param _winner is the Lottery winner
     */
    function submitNFT(address _winner) external{
        require(msg.sender == lottery, "only lottery can call this function");
        pending[_winner] = true;
        IRNG(RNG).seed(_winner);
    }

    /**
    * @dev can be claimed by a lottery winner after the RNG pending period passes
     */
    function claimNFT() external{
        require(pending[msg.sender], "you have nothing to claim");
        //get boost with the random num generated by RNG
        pending[msg.sender] = false;
        boosts[nonce] = _getBoost(IRNG(RNG).getRNG(msg.sender));
        _mint(msg.sender, nonce++);
    }

    function _getBoost(uint _rand) private view returns(uint){
        uint treasuryBal = treasury.balance;
        if(treasuryBal < a){
            return(a);
        }else if(treasuryBal >= b){
            //Find random between a and b
            return(_getRandomBetween(a,b,_rand));
        }else{
            //Find random between a and balance
            return(_getRandomBetween(a, treasuryBal, _rand));
        }
    }

    function _getRandomBetween(uint _a, uint _b, uint _rand) private pure returns(uint){
        return((_rand % _b) + _a);
    }
}
